What Phase 1 covers?

Phase 1 will involve the following core items (paraphrased from the roadmap):

1) Implementation of the “nano-ledger” concept (the 8-byte packet header with hash, prev pointer, critical flag)
2) Embedding that nano-header into UDP (or equivalent) packets
3) Verification of packet chains (hash chaining)
4) Basic smart contract (on Clarity on Stacks) support to record/anchor the chain of packets
5) A simple endpoint or demo of sending + verifying such packets (client/server)
6) Unit tests / integration tests for the above

Thus Phase 1 is essentially: build the minimal working system that sends packets with the nano-ledger header, chains them, and anchors/verifies them via a Clarity contract on Stacks, proving the concept end-to-end.


Implementation Plan

1) Define packet format 
Specify the nano-header structure:

struct NanoHeader {  
   uint64_t hash;          // 8 bytes: Blake3 or similar truncated to 8-bytes  
   uint64_t prev;          // 8 bytes: previous packet’s hash  
   bool critical;          // maybe 1 byte or bit for flag  
}  

Things to do:
- Decide how this header is embedded in the UDP packet (prepended to payload).
- Choose the hash algorithm (e.g., Blake3) and how to truncate to 8 bytes (64 bits).
- Define how “prev” is set (for first packet maybe zero or special value).
- Decide on endianness and serialization format (network order).
- Document the format clearly in code (e.g., in README or design doc).


2. Implement the nano-header generation & chaining

In the codebase (likely in blockudp.js or a new module) implement:
- Compute the packet payload hash (before header)
- Compute the truncated 8-byte representation
- Insert the prev value from the last packet sent in that chain/session
- Insert a critical flag if needed
- Serialize the header + payload into a UDP packet buffer

Maintain state for last packet hash for a given session/chain (could be in memory for now).

Implement a receiver that parses the header, verifies:
- The hash matches the payload
- The prev matches what the receiver expects (i.e., previous packet hash)
- Optionally record or log chain breaks (missing or mismatched).

Provide simple CLI/demo tools: e.g., sender.js and receiver.js.

3. Smart contract (Clarity) for anchoring packet chains

Write a Clarity smart contract (in nano-ledger.clar) that supports:

- Recording a packet chain anchor: maybe store (sender_address, last_hash, timestamp)
- A function anchor(hash:uint64, prev:uint64) that appends or updates the chain info.
- A function verify(hash:uint64, prev:uint64) -> bool to allow checking whether the chain is valid (based on stored state).

Deploy this contract on Stacks testnet (or local devnet) for testing.

Modify the sender side to call the contract after sending each packet (or after a batch) to anchor the chain. Use stacks-js or similar to send the transaction.

On receiver side, optionally fetch the on-chain stored prev value for a sender and compare.

4. Integration: send → chain anchor → receive

Combine the sender code, packet header chaining, on-chain anchoring and receiver code into an end-to-end demo.

For example:
- Sender sends N packets, each with nano header.
- For every packet (or every M packets) sender submits the header hash + prev to the Clarity contract.
- Receiver, upon getting packet K, verifies header locally and queries contract to verify stored state.
- If mismatch, mark chain broken and log.

Provide simple logging/metrics: number of packets, chain breaks, latency overhead of header & on-chain call.

5. Testing

- Unit tests for header generation/parsing (e.g., tests in tests/ directory).
- Integration tests: start sender + receiver locally (or in Docker) and simulate packet loss / reordering and observe chain behaviour.
- Smart contract tests (Clarity unit tests) for anchor and verify functions.
- Performance test: measure overhead (serialize/deserialise, hashing, on‐chain call latency) and document.
- Ensure errors are handled (e.g., invalid header, missing prev, on-chain failure).

6. Documentation

- Update README with the Phase 1 design: packet format, chaining logic, contract interface, how to run demo.
- Provide a diagram of packet flow (sender → network → receiver + blockchain anchor).
- Provide instructions for deploying contract to testnet / using stacks-js.
- Write “how to run” scripts: npm install, node sender.js, node receiver.js, etc.

7. Milestones & deliverables

Milestone 1: Packet header definition + sender/receiver code that chains locally (no blockchain yet).
Milestone 2: Clarity contract for anchoring chain + sender integration (records to chain).
Milestone 3: Full demo: sender → packet stream → chain anchor → receiver verifying chain + logs.
Milestone 4: Tests + documentation + performance overhead measurement.
Milestone 5: Release version v0.1 for Phase 1 (tag in git, update CHANGELOG).

Design decisions & considerations

- Hash truncation to 8 bytes: While truncating reduces overhead, it lose full collision resistance. Document the risk and rationale (eight bytes chosen for minimal overhead) and consider future upgrade path (e.g., 16 bytes).

- State management for “prev”: In a distributed system, how to agree on what the “prev” value is? For Phase 1 we can simplify by managing per-session chain locally. But note future scaling will require distributed state or consensus.

- On‐chain anchoring frequency: Each packet → on-chain may be too heavy. For Phase 1, we could anchor every packet or every N packets. Document this trade-off.

- Packet loss/reordering: UDP may drop or reorder packets. The chain logic must either accept gaps (skipping some) or mark broken chain. For Phase 1, we can mark broken chain and log. Future phases can handle recovery/retry.

- Latency & overhead: The hashing + header + blockchain call add overhead. Measure and report. For Phase 1 the goal is correctness, not full performance optimization.

- Security / tampering: The header hash + prev chain gives tamper-evidence (if payload altered or packet missing). But consider replay attacks, spoofing, etc. Phase 1 will not fully address all security but document limitations.

- Clarity contract state size & cost: On Stacks (and underlying Bitcoin anchoring) transactions incur fees. For Phase 1 use testnet or a very lightweight contract. In future will need batching or alternative anchoring.

- Session vs global chain: Decide if chain is per sender session (makes sense) or global. For Phase 1 make it per sender (identified by address).

- Versioning & future upgrades: Tag packet header version etc. Document that. In Phase 1 you might include a version byte.


File/Module Structure

/src
  /client
    sender.js
    receiver.js
    nano_header.js   // header encode/decode, hashing
  /contract
    nano-ledger.clar  // clarity contract
/tests
  nano_header.test.js
  integration.test.js
/README.md
/CHANGELOG.md

And update package.json scripts:

"scripts": {
  "test": "mocha tests/**/*.test.js",
  "start:sender": "node src/client/sender.js",
  "start:receiver": "node src/client/receiver.js"
}


Template for Phase 1

// File: src/client/nano_header.js
import crypto from 'crypto';

// Utility functions for encoding/decoding nano-ledger headers
export function computeHash(data) {
  const hash = crypto.createHash('blake2b512').update(data).digest();
  return hash.subarray(0, 8); // first 8 bytes (64 bits)
}

export function encodeHeader(prevHash, critical = false, payload) {
  const payloadHash = computeHash(payload);
  const header = Buffer.alloc(17); // 8 bytes hash + 8 bytes prev + 1 byte flag

  payloadHash.copy(header, 0);
  prevHash.copy(header, 8);
  header.writeUInt8(critical ? 1 : 0, 16);

  return Buffer.concat([header, payload]);
}

export function decodeHeader(buffer) {
  const hash = buffer.subarray(0, 8);
  const prev = buffer.subarray(8, 16);
  const critical = buffer.readUInt8(16) === 1;
  const payload = buffer.subarray(17);

  return { hash, prev, critical, payload };
}

export function verifyPacket(buffer, expectedPrev) {
  const { hash, prev, payload } = decodeHeader(buffer);
  const recalculated = computeHash(payload);
  const validHash = recalculated.equals(hash);
  const validPrev = prev.equals(expectedPrev);
  return { validHash, validPrev, hash };
}

// File: src/client/sender.js
import dgram from 'dgram';
import { encodeHeader, computeHash } from './nano_header.js';
import fs from 'fs';

const client = dgram.createSocket('udp4');
const HOST = '127.0.0.1';
const PORT = 5000;

let prevHash = Buffer.alloc(8, 0); // initial prev = 0x00

export async function sendPacket(message, critical = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, critical, payload);

  return new Promise((resolve, reject) => {
    client.send(packet, 0, packet.length, PORT, HOST, (err) => {
      if (err) return reject(err);
      prevHash = computeHash(payload);
      console.log(`Sent: ${message}`);
      resolve();
    });
  });
}

(async () => {
  const messages = ['hello', 'world', 'from', 'btcUDP'];
  for (const msg of messages) {
    await sendPacket(msg);
  }
  client.close();
})();

// File: src/client/receiver.js
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
const PORT = 5000;
let expectedPrev = Buffer.alloc(8, 0);

server.on('message', (msg, rinfo) => {
  const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);

  if (validHash && validPrev) {
    console.log(`✔ Packet valid from ${rinfo.address}:${rinfo.port}`);
    expectedPrev = hash;
  } else {
    console.warn(`⚠ Invalid packet detected (hash or prev mismatch)`);
  }
});

server.bind(PORT, () => console.log(`Receiver listening on port ${PORT}`));

// File: src/contract/nano-ledger.clar
(define-data-var packet-chain (map uint uint))

(define-public (anchor (hash uint) (prev uint))
  (begin
    (map-set packet-chain hash prev)
    (ok true)
  )
)

(define-read-only (verify (hash uint) (prev uint))
  (let ((stored (default-to u0 (map-get? packet-chain hash))))
    (ok (is-eq stored prev))
  )
)

// File: tests/nano_header.test.js
import assert from 'assert';
import { encodeHeader, decodeHeader, verifyPacket } from '../src/client/nano_header.js';

const prev = Buffer.alloc(8, 1);
const payload = Buffer.from('testdata');
const packet = encodeHeader(prev, false, payload);

const { hash, prev: decodedPrev } = decodeHeader(packet);
assert(decodedPrev.equals(prev));

const verification = verifyPacket(packet, prev);
assert(verification.validHash === true);

console.log('✅ All nano_header tests passed.');


On-chain anchoring integration (Stacks-JS call from sender.js)

// File: src/client/nano_header.js
import crypto from 'crypto';

// Utility functions for encoding/decoding nano-ledger headers
export function computeHash(data) {
  const hash = crypto.createHash('blake2b512').update(data).digest();
  return hash.subarray(0, 8); // first 8 bytes (64 bits)
}

export function encodeHeader(prevHash, critical = false, payload) {
  const payloadHash = computeHash(payload);
  const header = Buffer.alloc(17); // 8 bytes hash + 8 bytes prev + 1 byte flag

  payloadHash.copy(header, 0);
  prevHash.copy(header, 8);
  header.writeUInt8(critical ? 1 : 0, 16);

  return Buffer.concat([header, payload]);
}

export function decodeHeader(buffer) {
  const hash = buffer.subarray(0, 8);
  const prev = buffer.subarray(8, 16);
  const critical = buffer.readUInt8(16) === 1;
  const payload = buffer.subarray(17);

  return { hash, prev, critical, payload };
}

export function verifyPacket(buffer, expectedPrev) {
  const { hash, prev, payload } = decodeHeader(buffer);
  const recalculated = computeHash(payload);
  const validHash = recalculated.equals(hash);
  const validPrev = prev.equals(expectedPrev);
  return { validHash, validPrev, hash };
}

// File: src/client/stacks_anchor.js
import fetch from 'node-fetch';
import {
  AnchorMode,
  makeContractCall,
  broadcastTransaction,
  uintCV,
  bufferCV,
  PostConditionMode,
} from '@stacks/transactions';
import { StacksTestnet } from '@stacks/network';

// Simple helper to anchor packet hash to a deployed Clarity contract
// NOTE: for Phase 1 this uses a single private key to sign transactions.
// In production, never hard-code private keys; use secure key management.

const NETWORK = new StacksTestnet();
const CONTRACT_ADDRESS = process.env.STACKS_CONTRACT_ADDRESS || 'SP000000000000000000002Q6VF78';
const CONTRACT_NAME = process.env.STACKS_CONTRACT_NAME || 'nano-ledger';
const SENDER_PRIVATE_KEY = process.env.SENDER_PRIVATE_KEY || '';

export async function anchorOnChain(hashBuf, prevBuf) {
  if (!SENDER_PRIVATE_KEY) throw new Error('SENDER_PRIVATE_KEY not set');

  // convert buffers to uint CVs or buffers depending on the contract's expected types
  // Here contract expects two uints; we convert 8-byte buffers to big-endian uint
  function bufToUint(buf) {
    // Node BigInt from buffer (big-endian)
    let bn = 0n;
    for (const b of buf) {
      bn = (bn << 8n) + BigInt(b);
    }
    return bn.toString();
  }

  const hashUint = uintCV(Number(BigInt(bufToUint(hashBuf))));
  const prevUint = uintCV(Number(BigInt(bufToUint(prevBuf))));

  const txOptions = {
    contractAddress: CONTRACT_ADDRESS,
    contractName: CONTRACT_NAME,
    functionName: 'anchor',
    functionArgs: [hashUint, prevUint],
    senderKey: SENDER_PRIVATE_KEY,
    network: NETWORK,
    postConditionMode: PostConditionMode.Allow,
    anchorMode: AnchorMode.Any,
  };

  const tx = await makeContractCall(txOptions);
  const res = await broadcastTransaction(tx, NETWORK);
  return res;
}

// File: src/client/sender.js
import dgram from 'dgram';
import { encodeHeader, computeHash } from './nano_header.js';
import { anchorOnChain } from './stacks_anchor.js';

const client = dgram.createSocket('udp4');
const HOST = process.env.BTCUDP_HOST || '127.0.0.1';
const PORT = Number(process.env.BTCUDP_PORT || 5000);

let prevHash = Buffer.alloc(8, 0); // initial prev = 0x00

export async function sendPacket(message, critical = false, anchor = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, critical, payload);

  return new Promise((resolve, reject) => {
    client.send(packet, 0, packet.length, PORT, HOST, async (err) => {
      if (err) return reject(err);
      const newPrev = computeHash(payload);
      console.log(`Sent: ${message} (hash=${newPrev.toString('hex')})`);

      if (anchor) {
        try {
          const result = await anchorOnChain(newPrev, prevHash);
          console.log('Anchored on-chain:', result);
        } catch (e) {
          console.error('Anchor failed:', e.message || e);
        }
      }

      prevHash = newPrev;
      resolve();
    });
  });
}

(async () => {
  const messages = ['hello', 'world', 'from', 'btcUDP'];
  for (const msg of messages) {
    // anchor every packet for Phase 1 demo (can be batched later)
    await sendPacket(msg, false, true);
  }
  client.close();
})();

// File: src/client/receiver.js
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
const PORT = Number(process.env.BTCUDP_PORT || 5000);
let expectedPrev = Buffer.alloc(8, 0);

server.on('message', (msg, rinfo) => {
  const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);

  if (validHash && validPrev) {
    console.log(`✔ Packet valid from ${rinfo.address}:${rinfo.port}`);
    expectedPrev = hash;
  } else {
    console.warn(`⚠ Invalid packet detected (hash or prev mismatch)`);
  }
});

server.bind(PORT, () => console.log(`Receiver listening on port ${PORT}`));

// File: src/contract/nano-ledger.clar
(define-map packet-chain ((hash uint)) ((prev uint) (timestamp uint)))

(define-public (anchor (hash uint) (prev uint))
  (begin
    (map-set packet-chain (tuple (hash hash)) (tuple (prev prev) (timestamp (as-max-len (get-block-info?)))) )
    (ok true)
  )
)

(define-read-only (verify (hash uint) (prev uint))
  (let ((entry (map-get? packet-chain (tuple (hash hash)))))
    (match entry
      entry
      (ok (is-eq (get prev entry) prev))
      (ok false)
    )
  )
)

// File: tests/nano_header.test.js
import assert from 'assert';
import { encodeHeader, decodeHeader, verifyPacket } from '../src/client/nano_header.js';

const prev = Buffer.alloc(8, 1);
const payload = Buffer.from('testdata');
const packet = encodeHeader(prev, false, payload);

const { hash, prev: decodedPrev } = decodeHeader(packet);
assert(decodedPrev.equals(prev));

const verification = verifyPacket(packet, prev);
assert(verification.validHash === true);

console.log('✅ All nano_header tests passed.');

// README snippet (how to run Phase 1 demo)
/*
1) Install dependencies:
   npm install
   npm install @stacks/transactions @stacks/network node-fetch

2) Set environment variables for on-chain anchoring demo (optional for local-only run):
   export SENDER_PRIVATE_KEY="<hex-private-key>"
   export STACKS_CONTRACT_ADDRESS="SP..."
   export STACKS_CONTRACT_NAME="nano-ledger"

3) Start receiver:
   node src/client/receiver.js

4) Run sender (it will send and anchor each packet):
   node src/client/sender.js

Notes:
- For Phase 1 we anchor each packet on-chain for simplicity. This is expensive on mainnet; use testnet or batch anchors.
- Do NOT hardcode private keys in production. Use secure key management or a signing service.
*/


Adding the unit tests + mocks for anchorOnChain() so the test suite can run offline.

// File: src/client/nano_header.js
import crypto from 'crypto';

// Utility functions for encoding/decoding nano-ledger headers
export function computeHash(data) {
  const hash = crypto.createHash('blake2b512').update(data).digest();
  return hash.subarray(0, 8); // first 8 bytes (64 bits)
}

export function encodeHeader(prevHash, critical = false, payload) {
  const payloadHash = computeHash(payload);
  const header = Buffer.alloc(17); // 8 bytes hash + 8 bytes prev + 1 byte flag

  payloadHash.copy(header, 0);
  prevHash.copy(header, 8);
  header.writeUInt8(critical ? 1 : 0, 16);

  return Buffer.concat([header, payload]);
}

export function decodeHeader(buffer) {
  const hash = buffer.subarray(0, 8);
  const prev = buffer.subarray(8, 16);
  const critical = buffer.readUInt8(16) === 1;
  const payload = buffer.subarray(17);

  return { hash, prev, critical, payload };
}

export function verifyPacket(buffer, expectedPrev) {
  const { hash, prev, payload } = decodeHeader(buffer);
  const recalculated = computeHash(payload);
  const validHash = recalculated.equals(hash);
  const validPrev = prev.equals(expectedPrev);
  return { validHash, validPrev, hash };
}

// File: src/client/stacks_anchor.js
import {
  AnchorMode,
  makeContractCall,
  broadcastTransaction,
  uintCV,
  PostConditionMode,
} from '@stacks/transactions';
import { StacksTestnet } from '@stacks/network';

const NETWORK = new StacksTestnet();
const CONTRACT_ADDRESS = process.env.STACKS_CONTRACT_ADDRESS || 'SP000000000000000000002Q6VF78';
const CONTRACT_NAME = process.env.STACKS_CONTRACT_NAME || 'nano-ledger';
const SENDER_PRIVATE_KEY = process.env.SENDER_PRIVATE_KEY || '';

export async function anchorOnChain(hashBuf, prevBuf) {
  if (!SENDER_PRIVATE_KEY) throw new Error('SENDER_PRIVATE_KEY not set');

  const hashUint = uintCV(BigInt('0x' + hashBuf.toString('hex')));
  const prevUint = uintCV(BigInt('0x' + prevBuf.toString('hex')));

  const txOptions = {
    contractAddress: CONTRACT_ADDRESS,
    contractName: CONTRACT_NAME,
    functionName: 'anchor',
    functionArgs: [hashUint, prevUint],
    senderKey: SENDER_PRIVATE_KEY,
    network: NETWORK,
    postConditionMode: PostConditionMode.Allow,
    anchorMode: AnchorMode.Any,
  };

  const tx = await makeContractCall(txOptions);
  const res = await broadcastTransaction(tx, NETWORK);
  return res;
}

// File: src/client/sender.js
import dgram from 'dgram';
import { encodeHeader, computeHash } from './nano_header.js';
import { anchorOnChain } from './stacks_anchor.js';

const client = dgram.createSocket('udp4');
const HOST = process.env.BTCUDP_HOST || '127.0.0.1';
const PORT = Number(process.env.BTCUDP_PORT || 5000);

let prevHash = Buffer.alloc(8, 0); // initial prev = 0x00

export async function sendPacket(message, critical = false, anchor = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, critical, payload);

  return new Promise((resolve, reject) => {
    client.send(packet, 0, packet.length, PORT, HOST, async (err) => {
      if (err) return reject(err);
      const newPrev = computeHash(payload);
      console.log(`Sent: ${message} (hash=${newPrev.toString('hex')})`);

      if (anchor) {
        try {
          const result = await anchorOnChain(newPrev, prevHash);
          console.log('Anchored on-chain:', result);
        } catch (e) {
          console.error('Anchor failed:', e.message || e);
        }
      }

      prevHash = newPrev;
      resolve();
    });
  });
}

(async () => {
  const messages = ['hello', 'world', 'from', 'btcUDP'];
  for (const msg of messages) {
    await sendPacket(msg, false, true);
  }
  client.close();
})();

// File: src/client/receiver.js
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
const PORT = Number(process.env.BTCUDP_PORT || 5000);
let expectedPrev = Buffer.alloc(8, 0);

server.on('message', (msg, rinfo) => {
  const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);

  if (validHash && validPrev) {
    console.log(`✔ Packet valid from ${rinfo.address}:${rinfo.port}`);
    expectedPrev = hash;
  } else {
    console.warn(`⚠ Invalid packet detected (hash or prev mismatch)`);
  }
});

server.bind(PORT, () => console.log(`Receiver listening on port ${PORT}`));

// File: src/contract/nano-ledger.clar
(define-map packet-chain ((hash uint)) ((prev uint) (timestamp uint)))

(define-public (anchor (hash uint) (prev uint))
  (begin
    (map-set packet-chain (tuple (hash hash)) (tuple (prev prev) (timestamp u0)))
    (ok true)
  )
)

(define-read-only (verify (hash uint) (prev uint))
  (let ((entry (map-get? packet-chain (tuple (hash hash)))))
    (match entry
      entry
      (ok (is-eq (get prev entry) prev))
      (ok false)
    )
  )
)

// File: tests/nano_header.test.js
import assert from 'assert';
import { encodeHeader, decodeHeader, verifyPacket } from '../src/client/nano_header.js';

const prev = Buffer.alloc(8, 1);
const payload = Buffer.from('testdata');
const packet = encodeHeader(prev, false, payload);

const { hash, prev: decodedPrev } = decodeHeader(packet);
assert(decodedPrev.equals(prev));

const verification = verifyPacket(packet, prev);
assert(verification.validHash === true);

console.log('✅ All nano_header tests passed.');

// File: tests/stacks_anchor.test.js
import assert from 'assert';
import sinon from 'sinon';
import * as stacksTx from '@stacks/transactions';
import * as stacksAnchor from '../src/client/stacks_anchor.js';

// Mock makeContractCall and broadcastTransaction
sinon.stub(stacksTx, 'makeContractCall').callsFake(async () => ({ mockTx: true }));
sinon.stub(stacksTx, 'broadcastTransaction').callsFake(async (tx, net) => ({
  txid: '0x1234',
  success: true,
  network: net.url,
}));

process.env.SENDER_PRIVATE_KEY = 'abcdef123456';

(async () => {
  const hash = Buffer.alloc(8, 1);
  const prev = Buffer.alloc(8, 2);
  const result = await stacksAnchor.anchorOnChain(hash, prev);

  assert(result.success === true);
  assert(result.txid === '0x1234');

  console.log('✅ Stacks anchoring mock test passed.');
})();

// README snippet
/*
Run tests:
   npm install
   npm install mocha sinon @stacks/transactions @stacks/network
   npx mocha tests/*.test.js


Deployment guide (testnet setup, .env config, and running steps)

# btcUDP Phase 1 – Development and Deployment Guide

This guide explains how to set up, test, and deploy **Phase 1** of the `btcUDP` project, which includes UDP transmission, nano-ledger headers, and on-chain anchoring via Stacks.

---

## 📦 Project Overview

**btcUDP** is a lightweight UDP-based message protocol with built-in data integrity and optional blockchain anchoring. Phase 1 establishes the foundation by:

1. Building nano-ledger headers for each UDP packet.
2. Hash-linking messages for verifiable sequencing.
3. Anchoring packet hashes on the **Stacks blockchain** for immutable proof.

---

## 🧱 Project Structure

```
btcUDP/
├── src/
│   ├── client/
│   │   ├── sender.js
│   │   ├── receiver.js
│   │   ├── nano_header.js
│   │   └── stacks_anchor.js
│   └── contract/
│       └── nano-ledger.clar
├── tests/
│   ├── nano_header.test.js
│   └── stacks_anchor.test.js
├── package.json
└── README.md
```

---

## ⚙️ Installation

```bash
git clone https://github.com/vicdelgui86/btcUDP.git
cd btcUDP
npm install
```

Install required dependencies:
```bash
npm install mocha sinon @stacks/transactions @stacks/network
```

---

## 🔐 Environment Variables

Create a `.env` file in the root directory with the following:

```bash
STACKS_CONTRACT_ADDRESS=ST123YOURADDRESSHERE
STACKS_CONTRACT_NAME=nano-ledger
SENDER_PRIVATE_KEY=your_private_key_here
BTCUDP_HOST=127.0.0.1
BTCUDP_PORT=5000
```

You can generate a test private key using the Stacks CLI or the [Stacks Authenticator](https://explorer.stacks.co/).

---

## 🚀 Running the Network

**1. Start the Receiver**
```bash
node src/client/receiver.js
```

**2. Send Packets**
```bash
node src/client/sender.js
```
Each message will be hashed, transmitted via UDP, and optionally anchored on Stacks Testnet.

---

## 🔗 Clarity Contract Deployment

Deploy the `nano-ledger.clar` contract on Stacks Testnet:

```bash
clarinet deploy --network testnet src/contract/nano-ledger.clar
```

**Contract Functions:**
- `(anchor (hash uint) (prev uint))` — Records a new packet hash and its link.
- `(verify (hash uint) (prev uint))` — Validates if a packet’s previous hash matches.

---

## 🧪 Running Tests

To verify the packet logic and blockchain integration:

```bash
npx mocha tests/*.test.js
```

Expected output:
```
✅ All nano_header tests passed.
✅ Stacks anchoring mock test passed.
```

---

## 🧭 Phase 1 Summary

✔ Nano-ledger header format with 8-byte BLAKE2b hashes.  
✔ UDP sender/receiver with hash verification.  
✔ Clarity smart contract for anchoring.  
✔ On-chain integration through `@stacks/transactions`.  
✔ Automated test suite for validation.

---

## 🔜 Next Steps (Phase 2 Preview)

- Integrate multi-node synchronization.
- Add Merkle root aggregation for batches.
- Implement CLI monitoring dashboard.
- Add compression and encryption modules.

---

**Author:** Victor Delgado  
**Project:** btcUDP  
**Phase:** 1 – Nano Ledger Anchoring

*/


Docker support next (for running a local Stacks testnet and UDP nodes automatically)

# btcUDP Phase 1 – Development, Deployment, and Docker Setup

This guide explains how to set up, test, deploy, and run **Phase 1** of the `btcUDP` project with Docker, enabling a local Stacks testnet and UDP nodes.

---

## 📦 Project Overview

**btcUDP** is a UDP-based message protocol with data integrity and optional blockchain anchoring. Phase 1 includes:

1. Nano-ledger headers for each packet.
2. Hash-linked messages.
3. Optional on-chain anchoring via Stacks.

---

## 🧱 Project Structure

```
btcUDP/
├── src/
│   ├── client/
│   │   ├── sender.js
│   │   ├── receiver.js
│   │   ├── nano_header.js
│   │   └── stacks_anchor.js
│   └── contract/
│       └── nano-ledger.clar
├── tests/
│   ├── nano_header.test.js
│   └── stacks_anchor.test.js
├── docker-compose.yml
├── Dockerfile
├── package.json
└── README.md
```

---

## ⚙️ Installation

```bash
git clone https://github.com/vicdelgui86/btcUDP.git
cd btcUDP
npm install
```

Dependencies:
```bash
npm install mocha sinon @stacks/transactions @stacks/network node-fetch
```

---

## 🔐 Environment Variables

Create `.env` file:

```bash
STACKS_CONTRACT_ADDRESS=ST123YOURADDRESSHERE
STACKS_CONTRACT_NAME=nano-ledger
SENDER_PRIVATE_KEY=your_private_key_here
BTCUDP_HOST=127.0.0.1
BTCUDP_PORT=5000
```

---

## 🐳 Docker Setup

### Dockerfile
```Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["node", "src/client/receiver.js"]
```

### docker-compose.yml
```yaml
version: '3.8'
services:
  stacks-testnet:
    image: hirosystems/clarinet:latest
    container_name: stacks_testnet
    ports:
      - '3999:3999'
    command: clarinet develop --config clarinet.toml
    volumes:
      - .:/app

  btcudp-receiver:
    build: .
    container_name: btcudp_receiver
    environment:
      - BTCUDP_PORT=5000
      - BTCUDP_HOST=0.0.0.0
    ports:
      - '5000:5000'
    depends_on:
      - stacks-testnet

  btcudp-sender:
    build: .
    container_name: btcudp_sender
    environment:
      - BTCUDP_HOST=btcudp-receiver
      - BTCUDP_PORT=5000
      - SENDER_PRIVATE_KEY=abcdef123456
      - STACKS_CONTRACT_ADDRESS=ST123...
      - STACKS_CONTRACT_NAME=nano-ledger
    depends_on:
      - btcudp-receiver
```

### Run with Docker
```bash
docker-compose up --build
```
This starts:
- Local Stacks testnet (`clarinet`).
- UDP receiver node.
- UDP sender node sending & anchoring packets.

---

## 🔗 Contract Deployment

Inside the `stacks-testnet` container:
```bash
clarinet deploy --network testnet src/contract/nano-ledger.clar
```

---

## 🧪 Testing
```bash
npx mocha tests/*.test.js
```
Expected output:
```
✅ All nano_header tests passed.
✅ Stacks anchoring mock test passed.
```

---


End-to-end tests that run inside Docker, simulating multiple nodes sending and anchoring packets

# btcUDP Phase 1 – Development, Deployment, Docker, and End-to-End Tests

This guide explains how to set up, test, deploy, run Docker, and perform end-to-end simulations for **Phase 1** of `btcUDP`.

---

## 📦 Project Overview

**btcUDP** is a UDP-based messaging protocol with data integrity and optional blockchain anchoring. Phase 1 includes:

1. Nano-ledger headers.
2. Hash-linked message sequencing.
3. Optional on-chain anchoring via Stacks.

---

## 🧱 Project Structure

```
btcUDP/
├── src/
│   ├── client/
│   │   ├── sender.js
│   │   ├── receiver.js
│   │   ├── nano_header.js
│   │   └── stacks_anchor.js
│   └── contract/
│       └── nano-ledger.clar
├── tests/
│   ├── nano_header.test.js
│   ├── stacks_anchor.test.js
│   └── e2e.test.js
├── docker-compose.yml
├── Dockerfile
├── package.json
└── README.md
```

---

## 🐳 Docker End-to-End Tests

We simulate multiple sender/receiver nodes with Docker to validate Phase 1 functionality.

### 1. `tests/e2e.test.js`
```javascript
import assert from 'assert';
import dgram from 'dgram';
import { encodeHeader, computeHash, verifyPacket } from '../src/client/nano_header.js';

const PORT = 5500;
const HOST = '127.0.0.1';

function createReceiver() {
  return new Promise(resolve => {
    const server = dgram.createSocket('udp4');
    let expectedPrev = Buffer.alloc(8, 0);
    let received = [];

    server.on('message', (msg) => {
      const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);
      if (validHash && validPrev) {
        received.push(msg);
        expectedPrev = hash;
      }
    });

    server.bind(PORT, () => resolve({ server, received }));
  });
}

function createSender(messages) {
  return new Promise(resolve => {
    const client = dgram.createSocket('udp4');
    let prevHash = Buffer.alloc(8, 0);

    (async () => {
      for (const msg of messages) {
        const payload = Buffer.from(msg);
        const packet = encodeHeader(prevHash, false, payload);
        client.send(packet, 0, packet.length, PORT, HOST);
        prevHash = computeHash(payload);
        await new Promise(r => setTimeout(r, 50)); // small delay
      }
      client.close();
      resolve();
    })();
  });
}

(async () => {
  const receiver = await createReceiver();
  const messages = ['node1', 'node2', 'node3'];
  await createSender(messages);

  // wait for messages to be processed
  await new Promise(r => setTimeout(r, 200));
  assert(receiver.received.length === messages.length);

  console.log('✅ E2E UDP test passed');
  receiver.server.close();
})();
```

### 2. Running E2E Test with Docker
Add a `docker-compose.test.yml` if needed:
```yaml
version: '3.8'
services:
  btcudp-e2e:
    build: .
    container_name: btcudp_e2e
    environment:
      - BTCUDP_PORT=5500
      - BTCUDP_HOST=0.0.0.0
    command: npx mocha tests/e2e.test.js
```

Run:
```bash
docker-compose -f docker-compose.test.yml up --build
```

This spins up a container that runs a local receiver and sender inside Docker and validates UDP transmission and nano-ledger hash linking.

---

## ✅ Summary of Phase 1 Capabilities

- Nano-ledger header format with 8-byte BLAKE2b hashes.
- UDP sender/receiver with hash verification.
- Optional on-chain anchoring using Stacks.
- Dockerized local network for testnet and nodes.
- Unit tests and end-to-end simulation included.

---


Add batch anchoring for multiple packets to optimize testnet/mainnet gas usage

# btcUDP Phase 1 – Development, Deployment, Docker, E2E, and Batch Anchoring

This guide explains how to set up, test, deploy, run Docker, perform end-to-end simulations, and batch-anchor multiple UDP packets for **Phase 1** of `btcUDP`.

---

## 📦 Project Overview

**btcUDP** is a UDP-based messaging protocol with data integrity and optional blockchain anchoring. Phase 1 includes:

1. Nano-ledger headers.
2. Hash-linked message sequencing.
3. Optional on-chain anchoring via Stacks.
4. Batch anchoring multiple packets to reduce gas/transactions.

---

## 🧱 Project Structure

```
btcUDP/
├── src/
│   ├── client/
│   │   ├── sender.js
│   │   ├── receiver.js
│   │   ├── nano_header.js
│   │   └── stacks_anchor.js
│   └── contract/
│       └── nano-ledger.clar
├── tests/
│   ├── nano_header.test.js
│   ├── stacks_anchor.test.js
│   └── e2e.test.js
├── docker-compose.yml
├── Dockerfile
├── package.json
└── README.md
```

---

## ⚡ Batch Anchoring Implementation

**Purpose:** Anchor multiple packets in a single contract call to save gas and improve throughput.

### Update `stacks_anchor.js`
```javascript
export async function batchAnchorOnChain(hashBuffers, prevBuffers) {
  if (!SENDER_PRIVATE_KEY) throw new Error('SENDER_PRIVATE_KEY not set');
  if (hashBuffers.length !== prevBuffers.length) throw new Error('Arrays must be equal');

  const txOptionsArray = hashBuffers.map((hashBuf, idx) => {
    const prevBuf = prevBuffers[idx];
    return {
      hash: uintCV(BigInt('0x' + hashBuf.toString('hex'))),
      prev: uintCV(BigInt('0x' + prevBuf.toString('hex'))),
    };
  });

  // Flatten functionArgs: [hash1, prev1, hash2, prev2, ...]
  const functionArgs = txOptionsArray.flatMap(obj => [obj.hash, obj.prev]);

  const tx = await makeContractCall({
    contractAddress: CONTRACT_ADDRESS,
    contractName: CONTRACT_NAME,
    functionName: 'anchorBatch',
    functionArgs,
    senderKey: SENDER_PRIVATE_KEY,
    network: NETWORK,
    postConditionMode: PostConditionMode.Allow,
    anchorMode: AnchorMode.Any,
  });

  return await broadcastTransaction(tx, NETWORK);
}
```

### Update Clarity Contract `nano-ledger.clar`
```clarity
(define-public (anchorBatch (hashes (list 10 uint)) (prevs (list 10 uint)))
  (begin
    (for-each index hashes
      (let ((h (unwrap! (list-get hashes index) 0))
            (p (unwrap! (list-get prevs index) 0)))
        (map-set packet-chain (tuple (hash h)) (tuple (prev p) (timestamp u0)))))
    (ok true)))
```

> Adjust list size `10` to the maximum number of packets per batch as needed.

---

## 🧪 Using Batch Anchoring in Sender

```javascript
// Example: send and batch-anchor
const messages = ['msg1','msg2','msg3'];
const hashBuffers = [];
const prevBuffers = [];

for (const msg of messages) {
  const payload = Buffer.from(msg);
  const packet = encodeHeader(prevHash, false, payload);
  prevHash = computeHash(payload);
  hashBuffers.push(prevHash);
  prevBuffers.push(prevHash); // link to previous as needed
}

await batchAnchorOnChain(hashBuffers, prevBuffers);
```

---

## ✅ Summary of Phase 1 Enhancements

- Nano-ledger headers for UDP packets.
- Single packet and **batch on-chain anchoring**.
- Dockerized local testnet and nodes.
- Unit tests and end-to-end simulations.
- Reduced gas usage with batch anchoring.

---


Add automated Docker E2E tests for batch anchoring, so the entire pipeline can be validated in one command

# btcUDP Phase 1 – Full Development, Deployment, Docker, E2E, and Batch Anchoring

This guide explains setup, testing, deployment, Docker, end-to-end simulations, and batch anchoring for **Phase 1** of `btcUDP`.

---

## 📦 Project Overview

**btcUDP** is a UDP-based messaging protocol with data integrity and optional blockchain anchoring. Phase 1 includes:

1. Nano-ledger headers.
2. Hash-linked message sequencing.
3. Optional on-chain anchoring via Stacks.
4. Batch anchoring multiple packets.
5. Dockerized environment for testing nodes and Stacks testnet.

---

## 🧱 Project Structure

```
btcUDP/
├── src/
│   ├── client/
│   │   ├── sender.js
│   │   ├── receiver.js
│   │   ├── nano_header.js
│   │   └── stacks_anchor.js
│   └── contract/
│       └── nano-ledger.clar
├── tests/
│   ├── nano_header.test.js
│   ├── stacks_anchor.test.js
│   ├── e2e.test.js
│   └── e2e_batch.test.js
├── docker-compose.yml
├── Dockerfile
├── package.json
└── README.md
```

---

## 🐳 Docker Setup

- `stacks-testnet` – local Stacks devnet via Clarinet
- `btcudp-receiver` – UDP receiver container
- `btcudp-sender` – UDP sender container

```bash
docker-compose up --build
```

---

## ⚡ Batch Anchoring E2E Test

### `tests/e2e_batch.test.js`
```javascript
import assert from 'assert';
import dgram from 'dgram';
import { encodeHeader, computeHash, verifyPacket } from '../src/client/nano_header.js';
import { batchAnchorOnChain } from '../src/client/stacks_anchor.js';

const PORT = 5600;
const HOST = '127.0.0.1';

function createReceiver() {
  return new Promise(resolve => {
    const server = dgram.createSocket('udp4');
    let expectedPrev = Buffer.alloc(8, 0);
    let received = [];

    server.on('message', (msg) => {
      const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);
      if (validHash && validPrev) {
        received.push(msg);
        expectedPrev = hash;
      }
    });

    server.bind(PORT, () => resolve({ server, received }));
  });
}

function createSender(messages) {
  return new Promise(resolve => {
    const client = dgram.createSocket('udp4');
    let prevHash = Buffer.alloc(8, 0);
    const hashBuffers = [];
    const prevBuffers = [];

    (async () => {
      for (const msg of messages) {
        const payload = Buffer.from(msg);
        const packet = encodeHeader(prevHash, false, payload);
        client.send(packet, 0, packet.length, PORT, HOST);
        prevHash = computeHash(payload);
        hashBuffers.push(prevHash);
        prevBuffers.push(prevHash);
        await new Promise(r => setTimeout(r, 50));
      }

      // Batch anchor after sending all messages
      await batchAnchorOnChain(hashBuffers, prevBuffers);
      client.close();
      resolve();
    })();
  });
}

(async () => {
  const receiver = await createReceiver();
  const messages = ['batch1', 'batch2', 'batch3', 'batch4'];
  await createSender(messages);

  // wait for messages to be processed
  await new Promise(r => setTimeout(r, 500));
  assert(receiver.received.length === messages.length);

  console.log('✅ Batch E2E UDP test passed');
  receiver.server.close();
})();
```

### Docker Compose for Batch Test
```yaml
version: '3.8'
services:
  btcudp-e2e-batch:
    build: .
    container_name: btcudp_e2e_batch
    environment:
      - BTCUDP_PORT=5600
      - BTCUDP_HOST=0.0.0.0
      - SENDER_PRIVATE_KEY=abcdef123456
      - STACKS_CONTRACT_ADDRESS=ST123...
      - STACKS_CONTRACT_NAME=nano-ledger
    command: npx mocha tests/e2e_batch.test.js
```

Run:
```bash
docker-compose -f docker-compose.test.yml up --build
```

This performs full end-to-end testing of multiple UDP packets and batch anchoring in a single transaction.

---

## ✅ Summary of Phase 1 Enhancements

- Nano-ledger headers for UDP packets.
- Single and batch on-chain anchoring.
- Dockerized local network for testing nodes and Stacks testnet.
- Unit tests and end-to-end simulations for both single and batch packets.
- Optimized for gas usage with batch anchoring.

---


Integrate logging and metrics for sender/receiver throughput and on-chain anchoring stats

# btcUDP Phase 1 – Full Development, Deployment, Docker, E2E, Batch Anchoring, and Metrics

This guide explains setup, testing, deployment, Docker, end-to-end simulations, batch anchoring, and metrics for **Phase 1** of `btcUDP`.

---

## 📦 Project Overview

**btcUDP** is a UDP-based messaging protocol with data integrity and optional blockchain anchoring. Phase 1 includes:

1. Nano-ledger headers.
2. Hash-linked message sequencing.
3. Optional on-chain anchoring via Stacks.
4. Batch anchoring multiple packets.
5. Dockerized environment for testing nodes and Stacks testnet.
6. Logging and metrics for throughput and anchoring statistics.

---

## ⚡ Metrics Implementation

### Update `sender.js` for metrics
```javascript
import { encodeHeader, computeHash } from './nano_header.js';
import { anchorOnChain, batchAnchorOnChain } from './stacks_anchor.js';
import dgram from 'dgram';

const client = dgram.createSocket('udp4');
let prevHash = Buffer.alloc(8, 0);
let sentCount = 0;
let anchorCount = 0;
const startTime = Date.now();

export async function sendPacket(message, anchor = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, false, payload);

  client.send(packet, 0, packet.length, 5000, '127.0.0.1', async (err) => {
    if (err) return console.error(err);
    prevHash = computeHash(payload);
    sentCount++;

    if (anchor) {
      try {
        await anchorOnChain(prevHash, prevHash);
        anchorCount++;
      } catch(e) {
        console.error('Anchor failed:', e.message);
      }
    }

    logMetrics();
  });
}

function logMetrics() {
  const elapsed = (Date.now() - startTime) / 1000;
  console.log(`📊 Sent: ${sentCount}, Anchored: ${anchorCount}, Elapsed: ${elapsed.toFixed(2)}s`);
}
```

### Update `batchAnchorOnChain` for metrics
```javascript
export async function batchAnchorOnChain(hashBuffers, prevBuffers) {
  const res = await originalBatchAnchor(hashBuffers, prevBuffers); // your existing batch anchor logic
  console.log(`📊 Batch anchored ${hashBuffers.length} packets`);
  return res;
}
```

### Receiver metrics
```javascript
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
let expectedPrev = Buffer.alloc(8, 0);
let receivedCount = 0;
const startTime = Date.now();

server.on('message', (msg) => {
  const { validHash, validPrev } = verifyPacket(msg, expectedPrev);
  if (validHash && validPrev) {
    expectedPrev = msg.subarray(0,8);
    receivedCount++;
    logMetrics();
  }
});

function logMetrics() {
  const elapsed = (Date.now() - startTime) / 1000;
  console.log(`📈 Received: ${receivedCount}, Elapsed: ${elapsed.toFixed(2)}s`);
}

server.bind(5000, () => console.log('Receiver listening on 5000'));
```

### Docker Integration
- Metrics logs are printed to container stdout.
- Use `docker logs -f btcudp_sender` and `docker logs -f btcudp_receiver` to monitor throughput.

---

## ✅ Phase 1 Complete Feature Set

- Nano-ledger headers for UDP packets.
- Single and batch on-chain anchoring.
- Dockerized testnet and nodes.
- Unit tests and end-to-end simulations.
- Metrics and logging for sent, received, and anchored packets.
- Optimized for gas usage with batch anchoring.

---


Add optional encryption for payloads to secure messages over UDP

# btcUDP Phase 1 – Full Development, Deployment, Docker, E2E, Batch Anchoring, Metrics, and Encryption

This guide explains setup, testing, deployment, Docker, end-to-end simulations, batch anchoring, metrics, and optional encryption for **Phase 1** of `btcUDP`.

---

## 📦 Project Overview

**btcUDP** is a UDP-based messaging protocol with data integrity, optional blockchain anchoring, batch processing, logging, metrics, and encrypted payloads.

Phase 1 includes:
1. Nano-ledger headers.
2. Hash-linked message sequencing.
3. Optional on-chain anchoring via Stacks.
4. Batch anchoring multiple packets.
5. Dockerized environment for testing nodes and Stacks testnet.
6. Logging and metrics for throughput and anchoring.
7. Optional encryption for UDP payloads.

---

## 🔐 Encryption Implementation

### Update `nano_header.js`
```javascript
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || '0123456789abcdef0123456789abcdef'; // 32 bytes hex
const IV_LENGTH = 16;

export function encryptPayload(payload) {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
  let encrypted = cipher.update(payload);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return Buffer.concat([iv, encrypted]);
}

export function decryptPayload(data) {
  const iv = data.slice(0, IV_LENGTH);
  const encryptedText = data.slice(IV_LENGTH);
  const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
  let decrypted = decipher.update(encryptedText);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted;
}
```

### Update `sender.js` for encryption
```javascript
import { encryptPayload } from './nano_header.js';

export async function sendPacket(message, anchor = false, encrypt = false) {
  let payload = Buffer.from(message);
  if (encrypt) payload = encryptPayload(payload);

  const packet = encodeHeader(prevHash, false, payload);
  // send via UDP...
}
```

### Update `receiver.js` for decryption
```javascript
import { decryptPayload } from './nano_header.js';

server.on('message', (msg) => {
  const { validHash, validPrev, payload } = verifyPacket(msg, expectedPrev);
  if (validHash && validPrev) {
    let message = payload;
    if (process.env.ENCRYPTION_KEY) {
      message = decryptPayload(payload);
    }
    console.log('Received message:', message.toString());
    expectedPrev = msg.subarray(0,8);
    receivedCount++;
    logMetrics();
  }
});
```

### Notes
- Ensure `ENCRYPTION_KEY` is a 32-byte hex string.
- Encryption is optional and can be enabled via environment variable.

---

## ✅ Phase 1 Feature Set with Encryption

- Nano-ledger headers for UDP packets.
- Single and batch on-chain anchoring.
- Dockerized testnet and nodes.
- Unit tests and end-to-end simulations.
- Metrics and logging for sent, received, and anchored packets.
- Batch anchoring to optimize gas usage.
- Optional AES-256-CBC encryption for payloads over UDP.

---





