What Phase 1 covers?

Phase 1 will involve the following core items (paraphrased from the roadmap):

1) Implementation of the “nano-ledger” concept (the 8-byte packet header with hash, prev pointer, critical flag)
2) Embedding that nano-header into UDP (or equivalent) packets
3) Verification of packet chains (hash chaining)
4) Basic smart contract (on Clarity on Stacks) support to record/anchor the chain of packets
5) A simple endpoint or demo of sending + verifying such packets (client/server)
6) Unit tests / integration tests for the above

Thus Phase 1 is essentially: build the minimal working system that sends packets with the nano-ledger header, chains them, and anchors/verifies them via a Clarity contract on Stacks, proving the concept end-to-end.


Implementation Plan

1) Define packet format 
Specify the nano-header structure:

struct NanoHeader {  
   uint64_t hash;          // 8 bytes: Blake3 or similar truncated to 8-bytes  
   uint64_t prev;          // 8 bytes: previous packet’s hash  
   bool critical;          // maybe 1 byte or bit for flag  
}  

Things to do:
- Decide how this header is embedded in the UDP packet (prepended to payload).
- Choose the hash algorithm (e.g., Blake3) and how to truncate to 8 bytes (64 bits).
- Define how “prev” is set (for first packet maybe zero or special value).
- Decide on endianness and serialization format (network order).
- Document the format clearly in code (e.g., in README or design doc).


2. Implement the nano-header generation & chaining

In the codebase (likely in blockudp.js or a new module) implement:
- Compute the packet payload hash (before header)
- Compute the truncated 8-byte representation
- Insert the prev value from the last packet sent in that chain/session
- Insert a critical flag if needed
- Serialize the header + payload into a UDP packet buffer

Maintain state for last packet hash for a given session/chain (could be in memory for now).

Implement a receiver that parses the header, verifies:
- The hash matches the payload
- The prev matches what the receiver expects (i.e., previous packet hash)
- Optionally record or log chain breaks (missing or mismatched).

Provide simple CLI/demo tools: e.g., sender.js and receiver.js.

3. Smart contract (Clarity) for anchoring packet chains

Write a Clarity smart contract (in nano-ledger.clar) that supports:

- Recording a packet chain anchor: maybe store (sender_address, last_hash, timestamp)
- A function anchor(hash:uint64, prev:uint64) that appends or updates the chain info.
- A function verify(hash:uint64, prev:uint64) -> bool to allow checking whether the chain is valid (based on stored state).

Deploy this contract on Stacks testnet (or local devnet) for testing.

Modify the sender side to call the contract after sending each packet (or after a batch) to anchor the chain. Use stacks-js or similar to send the transaction.

On receiver side, optionally fetch the on-chain stored prev value for a sender and compare.

4. Integration: send → chain anchor → receive

Combine the sender code, packet header chaining, on-chain anchoring and receiver code into an end-to-end demo.

For example:
- Sender sends N packets, each with nano header.
- For every packet (or every M packets) sender submits the header hash + prev to the Clarity contract.
- Receiver, upon getting packet K, verifies header locally and queries contract to verify stored state.
- If mismatch, mark chain broken and log.

Provide simple logging/metrics: number of packets, chain breaks, latency overhead of header & on-chain call.

5. Testing

- Unit tests for header generation/parsing (e.g., tests in tests/ directory).
- Integration tests: start sender + receiver locally (or in Docker) and simulate packet loss / reordering and observe chain behaviour.
- Smart contract tests (Clarity unit tests) for anchor and verify functions.
- Performance test: measure overhead (serialize/deserialise, hashing, on‐chain call latency) and document.
- Ensure errors are handled (e.g., invalid header, missing prev, on-chain failure).

6. Documentation

- Update README with the Phase 1 design: packet format, chaining logic, contract interface, how to run demo.
- Provide a diagram of packet flow (sender → network → receiver + blockchain anchor).
- Provide instructions for deploying contract to testnet / using stacks-js.
- Write “how to run” scripts: npm install, node sender.js, node receiver.js, etc.

7. Milestones & deliverables

Milestone 1: Packet header definition + sender/receiver code that chains locally (no blockchain yet).
Milestone 2: Clarity contract for anchoring chain + sender integration (records to chain).
Milestone 3: Full demo: sender → packet stream → chain anchor → receiver verifying chain + logs.
Milestone 4: Tests + documentation + performance overhead measurement.
Milestone 5: Release version v0.1 for Phase 1 (tag in git, update CHANGELOG).

Design decisions & considerations

- Hash truncation to 8 bytes: While truncating reduces overhead, it lose full collision resistance. Document the risk and rationale (eight bytes chosen for minimal overhead) and consider future upgrade path (e.g., 16 bytes).

- State management for “prev”: In a distributed system, how to agree on what the “prev” value is? For Phase 1 we can simplify by managing per-session chain locally. But note future scaling will require distributed state or consensus.

- On‐chain anchoring frequency: Each packet → on-chain may be too heavy. For Phase 1, we could anchor every packet or every N packets. Document this trade-off.

- Packet loss/reordering: UDP may drop or reorder packets. The chain logic must either accept gaps (skipping some) or mark broken chain. For Phase 1, we can mark broken chain and log. Future phases can handle recovery/retry.

- Latency & overhead: The hashing + header + blockchain call add overhead. Measure and report. For Phase 1 the goal is correctness, not full performance optimization.

- Security / tampering: The header hash + prev chain gives tamper-evidence (if payload altered or packet missing). But consider replay attacks, spoofing, etc. Phase 1 will not fully address all security but document limitations.

- Clarity contract state size & cost: On Stacks (and underlying Bitcoin anchoring) transactions incur fees. For Phase 1 use testnet or a very lightweight contract. In future will need batching or alternative anchoring.

- Session vs global chain: Decide if chain is per sender session (makes sense) or global. For Phase 1 make it per sender (identified by address).

- Versioning & future upgrades: Tag packet header version etc. Document that. In Phase 1 you might include a version byte.


File/Module Structure

/src
  /client
    sender.js
    receiver.js
    nano_header.js   // header encode/decode, hashing
  /contract
    nano-ledger.clar  // clarity contract
/tests
  nano_header.test.js
  integration.test.js
/README.md
/CHANGELOG.md

And update package.json scripts:

"scripts": {
  "test": "mocha tests/**/*.test.js",
  "start:sender": "node src/client/sender.js",
  "start:receiver": "node src/client/receiver.js"
}


Template for Phase 1

// File: src/client/nano_header.js
import crypto from 'crypto';

// Utility functions for encoding/decoding nano-ledger headers
export function computeHash(data) {
  const hash = crypto.createHash('blake2b512').update(data).digest();
  return hash.subarray(0, 8); // first 8 bytes (64 bits)
}

export function encodeHeader(prevHash, critical = false, payload) {
  const payloadHash = computeHash(payload);
  const header = Buffer.alloc(17); // 8 bytes hash + 8 bytes prev + 1 byte flag

  payloadHash.copy(header, 0);
  prevHash.copy(header, 8);
  header.writeUInt8(critical ? 1 : 0, 16);

  return Buffer.concat([header, payload]);
}

export function decodeHeader(buffer) {
  const hash = buffer.subarray(0, 8);
  const prev = buffer.subarray(8, 16);
  const critical = buffer.readUInt8(16) === 1;
  const payload = buffer.subarray(17);

  return { hash, prev, critical, payload };
}

export function verifyPacket(buffer, expectedPrev) {
  const { hash, prev, payload } = decodeHeader(buffer);
  const recalculated = computeHash(payload);
  const validHash = recalculated.equals(hash);
  const validPrev = prev.equals(expectedPrev);
  return { validHash, validPrev, hash };
}

// File: src/client/sender.js
import dgram from 'dgram';
import { encodeHeader, computeHash } from './nano_header.js';
import fs from 'fs';

const client = dgram.createSocket('udp4');
const HOST = '127.0.0.1';
const PORT = 5000;

let prevHash = Buffer.alloc(8, 0); // initial prev = 0x00

export async function sendPacket(message, critical = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, critical, payload);

  return new Promise((resolve, reject) => {
    client.send(packet, 0, packet.length, PORT, HOST, (err) => {
      if (err) return reject(err);
      prevHash = computeHash(payload);
      console.log(`Sent: ${message}`);
      resolve();
    });
  });
}

(async () => {
  const messages = ['hello', 'world', 'from', 'btcUDP'];
  for (const msg of messages) {
    await sendPacket(msg);
  }
  client.close();
})();

// File: src/client/receiver.js
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
const PORT = 5000;
let expectedPrev = Buffer.alloc(8, 0);

server.on('message', (msg, rinfo) => {
  const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);

  if (validHash && validPrev) {
    console.log(`✔ Packet valid from ${rinfo.address}:${rinfo.port}`);
    expectedPrev = hash;
  } else {
    console.warn(`⚠ Invalid packet detected (hash or prev mismatch)`);
  }
});

server.bind(PORT, () => console.log(`Receiver listening on port ${PORT}`));

// File: src/contract/nano-ledger.clar
(define-data-var packet-chain (map uint uint))

(define-public (anchor (hash uint) (prev uint))
  (begin
    (map-set packet-chain hash prev)
    (ok true)
  )
)

(define-read-only (verify (hash uint) (prev uint))
  (let ((stored (default-to u0 (map-get? packet-chain hash))))
    (ok (is-eq stored prev))
  )
)

// File: tests/nano_header.test.js
import assert from 'assert';
import { encodeHeader, decodeHeader, verifyPacket } from '../src/client/nano_header.js';

const prev = Buffer.alloc(8, 1);
const payload = Buffer.from('testdata');
const packet = encodeHeader(prev, false, payload);

const { hash, prev: decodedPrev } = decodeHeader(packet);
assert(decodedPrev.equals(prev));

const verification = verifyPacket(packet, prev);
assert(verification.validHash === true);

console.log('✅ All nano_header tests passed.');


On-chain anchoring integration (Stacks-JS call from sender.js)

// File: src/client/nano_header.js
import crypto from 'crypto';

// Utility functions for encoding/decoding nano-ledger headers
export function computeHash(data) {
  const hash = crypto.createHash('blake2b512').update(data).digest();
  return hash.subarray(0, 8); // first 8 bytes (64 bits)
}

export function encodeHeader(prevHash, critical = false, payload) {
  const payloadHash = computeHash(payload);
  const header = Buffer.alloc(17); // 8 bytes hash + 8 bytes prev + 1 byte flag

  payloadHash.copy(header, 0);
  prevHash.copy(header, 8);
  header.writeUInt8(critical ? 1 : 0, 16);

  return Buffer.concat([header, payload]);
}

export function decodeHeader(buffer) {
  const hash = buffer.subarray(0, 8);
  const prev = buffer.subarray(8, 16);
  const critical = buffer.readUInt8(16) === 1;
  const payload = buffer.subarray(17);

  return { hash, prev, critical, payload };
}

export function verifyPacket(buffer, expectedPrev) {
  const { hash, prev, payload } = decodeHeader(buffer);
  const recalculated = computeHash(payload);
  const validHash = recalculated.equals(hash);
  const validPrev = prev.equals(expectedPrev);
  return { validHash, validPrev, hash };
}

// File: src/client/stacks_anchor.js
import fetch from 'node-fetch';
import {
  AnchorMode,
  makeContractCall,
  broadcastTransaction,
  uintCV,
  bufferCV,
  PostConditionMode,
} from '@stacks/transactions';
import { StacksTestnet } from '@stacks/network';

// Simple helper to anchor packet hash to a deployed Clarity contract
// NOTE: for Phase 1 this uses a single private key to sign transactions.
// In production, never hard-code private keys; use secure key management.

const NETWORK = new StacksTestnet();
const CONTRACT_ADDRESS = process.env.STACKS_CONTRACT_ADDRESS || 'SP000000000000000000002Q6VF78';
const CONTRACT_NAME = process.env.STACKS_CONTRACT_NAME || 'nano-ledger';
const SENDER_PRIVATE_KEY = process.env.SENDER_PRIVATE_KEY || '';

export async function anchorOnChain(hashBuf, prevBuf) {
  if (!SENDER_PRIVATE_KEY) throw new Error('SENDER_PRIVATE_KEY not set');

  // convert buffers to uint CVs or buffers depending on the contract's expected types
  // Here contract expects two uints; we convert 8-byte buffers to big-endian uint
  function bufToUint(buf) {
    // Node BigInt from buffer (big-endian)
    let bn = 0n;
    for (const b of buf) {
      bn = (bn << 8n) + BigInt(b);
    }
    return bn.toString();
  }

  const hashUint = uintCV(Number(BigInt(bufToUint(hashBuf))));
  const prevUint = uintCV(Number(BigInt(bufToUint(prevBuf))));

  const txOptions = {
    contractAddress: CONTRACT_ADDRESS,
    contractName: CONTRACT_NAME,
    functionName: 'anchor',
    functionArgs: [hashUint, prevUint],
    senderKey: SENDER_PRIVATE_KEY,
    network: NETWORK,
    postConditionMode: PostConditionMode.Allow,
    anchorMode: AnchorMode.Any,
  };

  const tx = await makeContractCall(txOptions);
  const res = await broadcastTransaction(tx, NETWORK);
  return res;
}

// File: src/client/sender.js
import dgram from 'dgram';
import { encodeHeader, computeHash } from './nano_header.js';
import { anchorOnChain } from './stacks_anchor.js';

const client = dgram.createSocket('udp4');
const HOST = process.env.BTCUDP_HOST || '127.0.0.1';
const PORT = Number(process.env.BTCUDP_PORT || 5000);

let prevHash = Buffer.alloc(8, 0); // initial prev = 0x00

export async function sendPacket(message, critical = false, anchor = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, critical, payload);

  return new Promise((resolve, reject) => {
    client.send(packet, 0, packet.length, PORT, HOST, async (err) => {
      if (err) return reject(err);
      const newPrev = computeHash(payload);
      console.log(`Sent: ${message} (hash=${newPrev.toString('hex')})`);

      if (anchor) {
        try {
          const result = await anchorOnChain(newPrev, prevHash);
          console.log('Anchored on-chain:', result);
        } catch (e) {
          console.error('Anchor failed:', e.message || e);
        }
      }

      prevHash = newPrev;
      resolve();
    });
  });
}

(async () => {
  const messages = ['hello', 'world', 'from', 'btcUDP'];
  for (const msg of messages) {
    // anchor every packet for Phase 1 demo (can be batched later)
    await sendPacket(msg, false, true);
  }
  client.close();
})();

// File: src/client/receiver.js
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
const PORT = Number(process.env.BTCUDP_PORT || 5000);
let expectedPrev = Buffer.alloc(8, 0);

server.on('message', (msg, rinfo) => {
  const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);

  if (validHash && validPrev) {
    console.log(`✔ Packet valid from ${rinfo.address}:${rinfo.port}`);
    expectedPrev = hash;
  } else {
    console.warn(`⚠ Invalid packet detected (hash or prev mismatch)`);
  }
});

server.bind(PORT, () => console.log(`Receiver listening on port ${PORT}`));

// File: src/contract/nano-ledger.clar
(define-map packet-chain ((hash uint)) ((prev uint) (timestamp uint)))

(define-public (anchor (hash uint) (prev uint))
  (begin
    (map-set packet-chain (tuple (hash hash)) (tuple (prev prev) (timestamp (as-max-len (get-block-info?)))) )
    (ok true)
  )
)

(define-read-only (verify (hash uint) (prev uint))
  (let ((entry (map-get? packet-chain (tuple (hash hash)))))
    (match entry
      entry
      (ok (is-eq (get prev entry) prev))
      (ok false)
    )
  )
)

// File: tests/nano_header.test.js
import assert from 'assert';
import { encodeHeader, decodeHeader, verifyPacket } from '../src/client/nano_header.js';

const prev = Buffer.alloc(8, 1);
const payload = Buffer.from('testdata');
const packet = encodeHeader(prev, false, payload);

const { hash, prev: decodedPrev } = decodeHeader(packet);
assert(decodedPrev.equals(prev));

const verification = verifyPacket(packet, prev);
assert(verification.validHash === true);

console.log('✅ All nano_header tests passed.');

// README snippet (how to run Phase 1 demo)
/*
1) Install dependencies:
   npm install
   npm install @stacks/transactions @stacks/network node-fetch

2) Set environment variables for on-chain anchoring demo (optional for local-only run):
   export SENDER_PRIVATE_KEY="<hex-private-key>"
   export STACKS_CONTRACT_ADDRESS="SP..."
   export STACKS_CONTRACT_NAME="nano-ledger"

3) Start receiver:
   node src/client/receiver.js

4) Run sender (it will send and anchor each packet):
   node src/client/sender.js

Notes:
- For Phase 1 we anchor each packet on-chain for simplicity. This is expensive on mainnet; use testnet or batch anchors.
- Do NOT hardcode private keys in production. Use secure key management or a signing service.
*/


Adding the unit tests + mocks for anchorOnChain() so the test suite can run offline.

// File: src/client/nano_header.js
import crypto from 'crypto';

// Utility functions for encoding/decoding nano-ledger headers
export function computeHash(data) {
  const hash = crypto.createHash('blake2b512').update(data).digest();
  return hash.subarray(0, 8); // first 8 bytes (64 bits)
}

export function encodeHeader(prevHash, critical = false, payload) {
  const payloadHash = computeHash(payload);
  const header = Buffer.alloc(17); // 8 bytes hash + 8 bytes prev + 1 byte flag

  payloadHash.copy(header, 0);
  prevHash.copy(header, 8);
  header.writeUInt8(critical ? 1 : 0, 16);

  return Buffer.concat([header, payload]);
}

export function decodeHeader(buffer) {
  const hash = buffer.subarray(0, 8);
  const prev = buffer.subarray(8, 16);
  const critical = buffer.readUInt8(16) === 1;
  const payload = buffer.subarray(17);

  return { hash, prev, critical, payload };
}

export function verifyPacket(buffer, expectedPrev) {
  const { hash, prev, payload } = decodeHeader(buffer);
  const recalculated = computeHash(payload);
  const validHash = recalculated.equals(hash);
  const validPrev = prev.equals(expectedPrev);
  return { validHash, validPrev, hash };
}

// File: src/client/stacks_anchor.js
import {
  AnchorMode,
  makeContractCall,
  broadcastTransaction,
  uintCV,
  PostConditionMode,
} from '@stacks/transactions';
import { StacksTestnet } from '@stacks/network';

const NETWORK = new StacksTestnet();
const CONTRACT_ADDRESS = process.env.STACKS_CONTRACT_ADDRESS || 'SP000000000000000000002Q6VF78';
const CONTRACT_NAME = process.env.STACKS_CONTRACT_NAME || 'nano-ledger';
const SENDER_PRIVATE_KEY = process.env.SENDER_PRIVATE_KEY || '';

export async function anchorOnChain(hashBuf, prevBuf) {
  if (!SENDER_PRIVATE_KEY) throw new Error('SENDER_PRIVATE_KEY not set');

  const hashUint = uintCV(BigInt('0x' + hashBuf.toString('hex')));
  const prevUint = uintCV(BigInt('0x' + prevBuf.toString('hex')));

  const txOptions = {
    contractAddress: CONTRACT_ADDRESS,
    contractName: CONTRACT_NAME,
    functionName: 'anchor',
    functionArgs: [hashUint, prevUint],
    senderKey: SENDER_PRIVATE_KEY,
    network: NETWORK,
    postConditionMode: PostConditionMode.Allow,
    anchorMode: AnchorMode.Any,
  };

  const tx = await makeContractCall(txOptions);
  const res = await broadcastTransaction(tx, NETWORK);
  return res;
}

// File: src/client/sender.js
import dgram from 'dgram';
import { encodeHeader, computeHash } from './nano_header.js';
import { anchorOnChain } from './stacks_anchor.js';

const client = dgram.createSocket('udp4');
const HOST = process.env.BTCUDP_HOST || '127.0.0.1';
const PORT = Number(process.env.BTCUDP_PORT || 5000);

let prevHash = Buffer.alloc(8, 0); // initial prev = 0x00

export async function sendPacket(message, critical = false, anchor = false) {
  const payload = Buffer.from(message);
  const packet = encodeHeader(prevHash, critical, payload);

  return new Promise((resolve, reject) => {
    client.send(packet, 0, packet.length, PORT, HOST, async (err) => {
      if (err) return reject(err);
      const newPrev = computeHash(payload);
      console.log(`Sent: ${message} (hash=${newPrev.toString('hex')})`);

      if (anchor) {
        try {
          const result = await anchorOnChain(newPrev, prevHash);
          console.log('Anchored on-chain:', result);
        } catch (e) {
          console.error('Anchor failed:', e.message || e);
        }
      }

      prevHash = newPrev;
      resolve();
    });
  });
}

(async () => {
  const messages = ['hello', 'world', 'from', 'btcUDP'];
  for (const msg of messages) {
    await sendPacket(msg, false, true);
  }
  client.close();
})();

// File: src/client/receiver.js
import dgram from 'dgram';
import { verifyPacket } from './nano_header.js';

const server = dgram.createSocket('udp4');
const PORT = Number(process.env.BTCUDP_PORT || 5000);
let expectedPrev = Buffer.alloc(8, 0);

server.on('message', (msg, rinfo) => {
  const { validHash, validPrev, hash } = verifyPacket(msg, expectedPrev);

  if (validHash && validPrev) {
    console.log(`✔ Packet valid from ${rinfo.address}:${rinfo.port}`);
    expectedPrev = hash;
  } else {
    console.warn(`⚠ Invalid packet detected (hash or prev mismatch)`);
  }
});

server.bind(PORT, () => console.log(`Receiver listening on port ${PORT}`));

// File: src/contract/nano-ledger.clar
(define-map packet-chain ((hash uint)) ((prev uint) (timestamp uint)))

(define-public (anchor (hash uint) (prev uint))
  (begin
    (map-set packet-chain (tuple (hash hash)) (tuple (prev prev) (timestamp u0)))
    (ok true)
  )
)

(define-read-only (verify (hash uint) (prev uint))
  (let ((entry (map-get? packet-chain (tuple (hash hash)))))
    (match entry
      entry
      (ok (is-eq (get prev entry) prev))
      (ok false)
    )
  )
)

// File: tests/nano_header.test.js
import assert from 'assert';
import { encodeHeader, decodeHeader, verifyPacket } from '../src/client/nano_header.js';

const prev = Buffer.alloc(8, 1);
const payload = Buffer.from('testdata');
const packet = encodeHeader(prev, false, payload);

const { hash, prev: decodedPrev } = decodeHeader(packet);
assert(decodedPrev.equals(prev));

const verification = verifyPacket(packet, prev);
assert(verification.validHash === true);

console.log('✅ All nano_header tests passed.');

// File: tests/stacks_anchor.test.js
import assert from 'assert';
import sinon from 'sinon';
import * as stacksTx from '@stacks/transactions';
import * as stacksAnchor from '../src/client/stacks_anchor.js';

// Mock makeContractCall and broadcastTransaction
sinon.stub(stacksTx, 'makeContractCall').callsFake(async () => ({ mockTx: true }));
sinon.stub(stacksTx, 'broadcastTransaction').callsFake(async (tx, net) => ({
  txid: '0x1234',
  success: true,
  network: net.url,
}));

process.env.SENDER_PRIVATE_KEY = 'abcdef123456';

(async () => {
  const hash = Buffer.alloc(8, 1);
  const prev = Buffer.alloc(8, 2);
  const result = await stacksAnchor.anchorOnChain(hash, prev);

  assert(result.success === true);
  assert(result.txid === '0x1234');

  console.log('✅ Stacks anchoring mock test passed.');
})();

// README snippet
/*
Run tests:
   npm install
   npm install mocha sinon @stacks/transactions @stacks/network
   npx mocha tests/*.test.js
*/










